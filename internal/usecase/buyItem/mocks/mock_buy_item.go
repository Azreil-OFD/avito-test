// Code generated by MockGen. DO NOT EDIT.
// Source: buyitem/buy_item.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	domain "github.com/Azreil-OFD/Avito-test/internal/infrastructure/domain"
	gomock "github.com/golang/mock/gomock"
)

// MockBuyItemRepository is a mock of BuyItemRepository interface.
type MockBuyItemRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBuyItemRepositoryMockRecorder
}

// MockBuyItemRepositoryMockRecorder is the mock recorder for MockBuyItemRepository.
type MockBuyItemRepositoryMockRecorder struct {
	mock *MockBuyItemRepository
}

// NewMockBuyItemRepository creates a new mock instance.
func NewMockBuyItemRepository(ctrl *gomock.Controller) *MockBuyItemRepository {
	mock := &MockBuyItemRepository{ctrl: ctrl}
	mock.recorder = &MockBuyItemRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBuyItemRepository) EXPECT() *MockBuyItemRepositoryMockRecorder {
	return m.recorder
}

// AddToInventory mocks base method.
func (m *MockBuyItemRepository) AddToInventory(ctx context.Context, userID int, itemType string, quantity int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddToInventory", ctx, userID, itemType, quantity)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddToInventory indicates an expected call of AddToInventory.
func (mr *MockBuyItemRepositoryMockRecorder) AddToInventory(ctx, userID, itemType, quantity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToInventory", reflect.TypeOf((*MockBuyItemRepository)(nil).AddToInventory), ctx, userID, itemType, quantity)
}

// DeductCoins mocks base method.
func (m *MockBuyItemRepository) DeductCoins(ctx context.Context, userID, amount int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeductCoins", ctx, userID, amount)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeductCoins indicates an expected call of DeductCoins.
func (mr *MockBuyItemRepositoryMockRecorder) DeductCoins(ctx, userID, amount interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeductCoins", reflect.TypeOf((*MockBuyItemRepository)(nil).DeductCoins), ctx, userID, amount)
}

// GetMerchItem mocks base method.
func (m *MockBuyItemRepository) GetMerchItem(ctx context.Context, itemName string) (domain.MerchStore, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMerchItem", ctx, itemName)
	ret0, _ := ret[0].(domain.MerchStore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMerchItem indicates an expected call of GetMerchItem.
func (mr *MockBuyItemRepositoryMockRecorder) GetMerchItem(ctx, itemName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMerchItem", reflect.TypeOf((*MockBuyItemRepository)(nil).GetMerchItem), ctx, itemName)
}

// GetUserByID mocks base method.
func (m *MockBuyItemRepository) GetUserByID(ctx context.Context, userID int) (domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserByID", ctx, userID)
	ret0, _ := ret[0].(domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockBuyItemRepositoryMockRecorder) GetUserByID(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockBuyItemRepository)(nil).GetUserByID), ctx, userID)
}

// MocktrManager is a mock of trManager interface.
type MocktrManager struct {
	ctrl     *gomock.Controller
	recorder *MocktrManagerMockRecorder
}

// MocktrManagerMockRecorder is the mock recorder for MocktrManager.
type MocktrManagerMockRecorder struct {
	mock *MocktrManager
}

// NewMocktrManager creates a new mock instance.
func NewMocktrManager(ctrl *gomock.Controller) *MocktrManager {
	mock := &MocktrManager{ctrl: ctrl}
	mock.recorder = &MocktrManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktrManager) EXPECT() *MocktrManagerMockRecorder {
	return m.recorder
}

// Do mocks base method.
func (m *MocktrManager) Do(ctx context.Context, fn func(context.Context) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Do", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Do indicates an expected call of Do.
func (mr *MocktrManagerMockRecorder) Do(ctx, fn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MocktrManager)(nil).Do), ctx, fn)
}
